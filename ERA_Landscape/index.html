<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ERA Graph</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üåç</text></svg>">
<style>
  html, body { height: 100%; margin: 0; padding: 0; }
  #network { width: 100%; height: 100vh; border: 0; }
  .legend { position: fixed; top: 10px; right: 10px; background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 10px; font-family: sans-serif; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; }
  .legend div { margin: 4px 0; }
  .legend .dot { display:inline-block; width:12px; height:12px; border-radius:50%; background:#888; margin-right:6px; vertical-align:middle; }
  .legend .box { display:inline-block; width:12px; height:12px; background:#aaa; margin-right:6px; vertical-align:middle; }
  .legend .tri { display:inline-block; width:0; height:0; border-left:6px solid transparent; border-right:6px solid transparent; border-bottom:12px solid #ce93d8; margin-right:6px; vertical-align:middle; }
  .legend .hex { display:inline-block; width:10px; height:10px; background:#999; clip-path: polygon(30% 0%, 70% 0%, 100% 50%, 70% 100%, 30% 100%, 0% 50%); margin-right:6px; vertical-align:middle; }
  #loading { position: fixed; top:0; left:0; right:0; bottom:0; background: rgba(255,255,255,0.92); display:flex; align-items:center; justify-content:center; z-index: 9999; font-family: sans-serif; }
  #loading .panel { text-align:center; color:#333; }
  #loading .title { font-size: 20px; font-weight: 600; margin-bottom: 6px; }
  #loading .sub { font-size: 13px; color:#666; }
  #toolbar { position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 10px; font-family: sans-serif; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; }
  #toolbar button { margin-right: 6px; }
  #curationModal { position: fixed; top:0; left:0; right:0; bottom:0; background: transparent; display:none; align-items:flex-end; justify-content:flex-start; z-index: 2000; padding: 20px; pointer-events: none; }
  #curationPanel { width: 720px; max-width: 95vw; max-height: 85vh; overflow: auto; background: rgba(255,255,255,0.90); border-radius: 10px; padding: 14px; box-shadow: 0 4px 18px rgba(0,0,0,0.25); font-family: sans-serif; pointer-events: auto; }
  #curationPanel h3 { margin: 0 0 6px 0; }
  #curationList { margin-top: 8px; }
  #curationList div { margin: 4px 0; }
  #toast { position: fixed; bottom: 16px; right: 16px; background: rgba(0,0,0,0.8); color:#fff; padding:8px 12px; border-radius:8px; display:none; z-index:3000; font-family: sans-serif; }
  #curationHandle { user-select:none; cursor: move; background: rgba(0,0,0,0.08); border-radius: 8px; padding: 6px 8px; margin: 0 0 8px; font-size: 12px; color:#444; }
  #curationUrl { font-size: 12px; color:#3366cc; margin: 4px 0 8px; }
  #physicsModal { position: fixed; top:0; left:0; right:0; bottom:0; background: transparent; display:none; align-items:center; justify-content:center; z-index: 2500; pointer-events: none; }
  #networkModal { position: fixed; top:0; left:0; right:0; bottom:0; background: transparent; display:none; align-items:center; justify-content:center; z-index: 2500; pointer-events: none; }
  #physicsPanel { width: 380px; max-width: 90vw; background: rgba(255,255,255,0.75); border-radius: 10px; padding: 14px; box-shadow: 0 4px 18px rgba(0,0,0,0.25); font-family: sans-serif; pointer-events: auto; backdrop-filter: blur(8px); }
  #physicsHandle { user-select:none; cursor: move; background: rgba(0,0,0,0.08); border-radius: 8px; padding: 6px 8px; margin: 0 0 8px; font-size: 12px; color:#444; }
  #networkPanel { width: 420px; max-width: 90vw; background: rgba(255,255,255,0.75); border-radius: 10px; padding: 14px; box-shadow: 0 4px 18px rgba(0,0,0,0.25); font-family: sans-serif; pointer-events: auto; backdrop-filter: blur(8px); }
  #networkHandle { user-select:none; cursor: move; background: rgba(0,0,0,0.08); border-radius: 8px; padding: 6px 8px; margin: 0 0 8px; font-size: 12px; color:#444; }
  #physicsPanel h3 { margin: 0 0 16px 0; }
  .slider-group { margin: 12px 0; }
  .slider-group label { display: block; margin-bottom: 4px; font-size: 14px; font-weight: 500; }
  .slider-group input[type="range"] { width: 100%; }
  .slider-value { float: right; color: #666; font-size: 13px; }
  .slider-value-float { 
    position: absolute; 
    top: -24px; 
    background: #333; 
    color: white; 
    padding: 2px 6px; 
    border-radius: 3px; 
    font-size: 11px; 
    pointer-events: none;
    white-space: nowrap;
    transform: translateX(-50%);
  }
</style>
<script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<!-- Google Sheets API -->
<script src="https://apis.google.com/js/api.js"></script>
<script src="https://accounts.google.com/gsi/client" async defer></script>
</head>
<body>
<div id="network"></div>
<div id="loading"><div class="panel"><div class="title">Loading graph‚Ä¶</div><div class="sub"><span id="pct">0</span>% ‚Ä¢ est <span id="eta">‚Äî</span> sec</div></div></div>
<div id="toolbar">
  <button id="fitBtn" title="Zoom to show all nodes">Fit</button>
  <button id="qeSaveTop" style="margin-left:8px; font-weight:600;" title="Save pending edits to Google Sheet">Save Edit</button>
  <span id="unsavedBadge" style="display:none; margin-left:6px; color:#c00; font-weight:600;">‚Ä¢ unsaved edit</span>
  
  <button id="refreshBtn" style="margin-left:8px;" title="Reload data from Google Sheet (discards unsaved edits)">‚Üª Re-Load</button>
  <button id="physicsBtn" style="margin-left:8px;" title="Adjust physics parameters">‚öôÔ∏è Physics</button>
  <button id="networkBtn" style="margin-left:8px;" title="Adjust network settings">üåê Network</button>
  <button id="signInBtn" onclick="handleSignIn()" style="margin-left:8px;" title="Sign in with Google to enable editing">üîê Sign In</button>
</div>
<div id="toolbar" style="position: fixed; top: 80px; left: 10px; background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 10px; font-family: sans-serif; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000;">
  <div id="quickEditor" style="margin-top:0; font-size:12px;">
    <div style="margin-bottom:4px; font-weight:600;">Quick Editor</div>
    <div style="display:flex; flex-wrap:wrap; gap:6px; align-items:center;">
      <div>
        <div style="margin-bottom:2px;">
          <label style="margin-right:6px;"><input type="radio" name="fromType" value="person"> Person</label>
          <label style="margin-right:6px;"><input type="radio" name="fromType" value="project"> Project</label>
          <label><input type="radio" name="fromType" value="organization" checked> Org</label>
        </div>
        <label>From <input id="qeFrom" list="nodeList" style="width:180px;"></label>
      </div>
      <label>Rel
        <select id="qeRel">
          <option value="partnership">partnership</option>
          <option value="affiliation">affiliation</option>
          <option value="membership">membership</option>
          <option value="__custom">Custom‚Ä¶</option>
          <option value="__none">None</option>
        </select>
      </label>
      <div>
        <div style="margin-bottom:2px;">
          <label style="margin-right:6px;"><input type="radio" name="toType" value="person"> Person</label>
          <label style="margin-right:6px;"><input type="radio" name="toType" value="project"> Project</label>
          <label><input type="radio" name="toType" value="organization" checked> Org</label>
        </div>
        <label>To <input id="qeTo" list="nodeList" style="width:180px;"></label>
      </div>
      <input id="qeRelCustom" placeholder="custom relationship" style="width:160px; display:none;">
      <button id="qeAdd">Add/Update</button>
      <button id="qeRemove">Remove</button>
      <button id="qeUndo">Undo</button>
    </div>
    <datalist id="nodeList"></datalist>
  </div>
</div>
<div class="legend">
  <div><span class="dot" style="background:#6aa7ff"></span> Person</div>
  <div><span class="tri"></span> Project</div>
  <div><span class="hex"></span> Event</div>
  <div><span class="box" style="background:#a8dadc"></span> Organization</div>
</div>
<div id="curationModal">
  <div id="curationPanel">
    <div id="curationHandle">Drag here to reposition</div>
    <h3>
      <label style="font-weight:normal;">
        <input type="checkbox" id="sourceToggle" checked> Curate partners for:
      </label>
      <a id="curationSourceLink" href="#" target="_blank"><span id="curationSource"></span></a>
    </h3>
    <div><a id="curationUrl" href="#" target="_blank"></a></div>
    <div style="margin-top:8px;">
      <label style="font-size:12px;">URL: <input type="text" id="curationUrlInput" style="width:300px;" placeholder="https://..."></label>
    </div>
    <div style="margin-top:8px;">
      <label style="font-size:12px;">Type:</label>
      <label style="font-size:12px; margin-left:10px;"><input type="radio" name="modalNodeType" value="person"> Person</label>
      <label style="font-size:12px; margin-left:10px;"><input type="radio" name="modalNodeType" value="project"> Project</label>
      <label style="font-size:12px; margin-left:10px;"><input type="radio" name="modalNodeType" value="organization"> Organization</label>
    </div>
    <div id="curationInfo" style="font-size:12px;color:#666"></div>
    <div id="curationList"></div>
    <div style="margin-top:10px;">
      <button id="closeCuration" style="float:right">Close</button>
    </div>
  </div>
  </div>
<div id="edgeModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.3); z-index:9999; align-items:center; justify-content:center;">
  <div id="edgePanel" style="background:white; padding:20px; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.3); min-width:400px; max-width:600px; position:relative;">
    <h3 style="margin-top:0;">Edit Connection</h3>
    <div style="margin:10px 0;">
      <strong id="edgeFromLabel"></strong> ‚Üí <strong id="edgeToLabel"></strong>
    </div>
    <div style="margin:15px 0;">
      <label style="font-size:12px;">Relationship: 
        <select id="edgeRelSelect" style="margin-left:10px;">
          <option value="partnership">partnership</option>
          <option value="affiliation">affiliation</option>
          <option value="membership">membership</option>
          <option value="__custom">Custom...</option>
        </select>
      </label>
      <input id="edgeRelCustom" placeholder="custom relationship" style="width:160px; display:none; margin-left:10px;">
    </div>
    <div style="margin-top:20px;">
      <button id="deleteEdge" style="background:#dc3545; color:white; border:none; padding:8px 16px; border-radius:4px; cursor:pointer;">Delete Connection</button>
      <button id="closeEdgeModal" style="float:right; padding:8px 16px; border-radius:4px; cursor:pointer;">Close</button>
    </div>
  </div>
</div>
<div id="toast"></div>
<div id="physicsModal">
  <div id="physicsPanel">
    <div id="physicsHandle">Drag here to reposition</div>
    <h3 style="margin: 0 0 6px 0;">‚öôÔ∏è Physics Settings</h3>
    <p style="font-size: 12px; color: #666; margin: 0 0 12px 0;">Adjust network layout in real-time</p>
    
    <div class="slider-group">
      <label style="text-align:center; display:block;">Central Gravity</label>
      <div style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:11px; color:#666; width:40px;">loose</span>
        <div style="flex:1; position:relative;">
          <input type="range" id="centralGravity" min="0" max="0.8" step="0.01" value="0.15" style="width:100%;">
          <span class="slider-value-float" id="centralGravityVal">0.15</span>
        </div>
        <span style="font-size:11px; color:#666; width:40px; text-align:right;">tight</span>
      </div>
    </div>
    
    <div class="slider-group">
      <label style="text-align:center; display:block;">Node Spacing</label>
      <div style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:11px; color:#666; width:40px;">short</span>
        <div style="flex:1; position:relative;">
          <input type="range" id="springLength" min="50" max="300" step="5" value="120" style="width:100%;">
          <span class="slider-value-float" id="springLengthVal">120</span>
        </div>
        <span style="font-size:11px; color:#666; width:40px; text-align:right;">long</span>
      </div>
    </div>
    
    <div class="slider-group">
      <label style="text-align:center; display:block;">Edge Springs</label>
      <div style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:11px; color:#666; width:40px;">loose</span>
        <div style="flex:1; position:relative;">
          <input type="range" id="springConstant" min="0.001" max="0.1" step="0.001" value="0.02" style="width:100%;">
          <span class="slider-value-float" id="springConstantVal">0.02</span>
        </div>
        <span style="font-size:11px; color:#666; width:40px; text-align:right;">tight</span>
      </div>
    </div>
    
    <div class="slider-group">
      <label style="text-align:center; display:block;">Avoid Overlap</label>
      <div style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:11px; color:#666; width:40px;">weak</span>
        <div style="flex:1; position:relative;">
          <input type="range" id="avoidOverlap" min="0" max="1" step="0.05" value="0.2" style="width:100%;">
          <span class="slider-value-float" id="avoidOverlapVal">0.2</span>
        </div>
        <span style="font-size:11px; color:#666; width:40px; text-align:right;">strong</span>
      </div>
    </div>
    
    <div class="slider-group">
      <label style="text-align:center; display:block;">Edge Length Multiplier</label>
      <div style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:11px; color:#666; width:40px;">low</span>
        <div style="flex:1; position:relative;">
          <input type="range" id="edgeMultiplier" min="0" max="30" step="1" value="10" style="width:100%;">
          <span class="slider-value-float" id="edgeMultiplierVal">10</span>
        </div>
        <span style="font-size:11px; color:#666; width:40px; text-align:right;">high</span>
      </div>
    </div>
    
    <div class="slider-group">
      <label style="text-align:center; display:block;">Edge Length Max</label>
      <div style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:11px; color:#666; width:40px;">low</span>
        <div style="flex:1; position:relative;">
          <input type="range" id="maxEdgeLength" min="100" max="500" step="10" value="250" style="width:100%;">
          <span class="slider-value-float" id="maxEdgeLengthVal">250</span>
        </div>
        <span style="font-size:11px; color:#666; width:40px; text-align:right;">high</span>
      </div>
    </div>
    
    <div style="margin-top: 20px; display: flex; gap: 8px;">
      <button id="resetPhysics" style="flex: 1; padding: 8px;">Reset to Defaults</button>
      <button id="applyPhysics" style="flex: 1; padding: 8px; font-weight: 600; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Done</button>
    </div>
  </div>
</div>
<div id="networkModal">
  <div id="networkPanel">
    <div id="networkHandle">Drag here to reposition</div>
    <h3 style="margin: 0 0 6px 0;">üåê Network Settings</h3>
    <p style="font-size: 12px; color: #666; margin: 0 0 12px 0;">Adjust visual appearance</p>
    
    <div class="slider-group">
      <label style="text-align:center; display:block;">Node Scaling</label>
      <div style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:11px; color:#666; width:60px;">constant</span>
        <div style="flex:1; position:relative;">
          <input type="range" id="scalingIntensity" min="0" max="1.0" step="0.05" value="1.0" style="width:100%;">
          <span class="slider-value-float" id="scalingIntensityVal">1.0</span>
        </div>
        <span style="font-size:11px; color:#666; width:60px; text-align:right;">logarithmic</span>
      </div>
    </div>
    
    <div class="slider-group">
      <label style="text-align:center; display:block;">Node Size</label>
      <div style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:11px; color:#666; width:60px;">small</span>
        <div style="flex:1; position:relative;">
          <input type="range" id="nodeSize" min="0.5" max="2.0" step="0.1" value="1.0" style="width:100%;">
          <span class="slider-value-float" id="nodeSizeVal">1.0</span>
        </div>
        <span style="font-size:11px; color:#666; width:60px; text-align:right;">large</span>
      </div>
    </div>
    
    <div class="slider-group">
      <label style="text-align:center; display:block;">Edge Fading</label>
      <div style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:11px; color:#666; width:60px;">strong</span>
        <div style="flex:1; position:relative;">
          <input type="range" id="edgeFading" min="0" max="1.0" step="0.1" value="1.0" style="width:100%;">
          <span class="slider-value-float" id="edgeFadingVal">1.0</span>
        </div>
        <span style="font-size:11px; color:#666; width:60px; text-align:right;">none</span>
      </div>
    </div>
    
    <div class="slider-group">
      <label style="text-align:center; display:block;">Edge Thickness</label>
      <div style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:11px; color:#666; width:60px;">extreme</span>
        <div style="flex:1; position:relative;">
          <input type="range" id="edgeThickness" min="0" max="2.0" step="0.1" value="1.0" style="width:100%;">
          <span class="slider-value-float" id="edgeThicknessVal">1.0</span>
        </div>
        <span style="font-size:11px; color:#666; width:60px; text-align:right;">subtle</span>
      </div>
    </div>
    
    <div style="margin-top: 20px; display: flex; gap: 8px;">
      <button id="resetNetwork" style="flex: 1; padding: 8px;">Reset to Defaults</button>
      <button id="applyNetwork" style="flex: 1; padding: 8px; font-weight: 600; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Done</button>
    </div>
  </div>
</div>
<script>
  // ========== Google Sheets API Configuration & Functions ==========
  
  // Configuration
  const SHEET_ID = '1cR5X2xFSGffivfsMjyHDDeDJQv6R0kQpVUJsEJ2_1yY';
  const API_KEY = 'AIzaSyBp23GwrTURmM3Z1ERZocotnu3Tn96TmUo';
  const CLIENT_ID = '57881875374-flipnf45tc25cq7emcr9qhvq7unk16n5.apps.googleusercontent.com';
  const SCOPES = 'https://www.googleapis.com/auth/spreadsheets';
  
  // State variables
  let sheetsApiReady = false;
  let tokenClient = null;
  let accessToken = null;
  let pendingSaveAfterAuth = false;
  
  /**
   * Parse node type from ID prefix (person::, org::, project::)
   * @param {string} id - Node ID like "person::John Doe"
   * @returns {string} Type: 'person', 'project', or 'organization'
   */
  function parseTypeFromId(id) {
    if (!id) return 'organization';
    if (id.startsWith('person::')) return 'person';
    if (id.startsWith('project::')) return 'project';
    if (id.startsWith('event::')) return 'event';
    return 'organization';
  }
  
  /**
   * Get visual properties (color, shape) for a node type
   * @param {string} type - Node type: 'person', 'project', 'organization', or 'event'
   * @returns {Object} {color: {background, border}, shape}
   */
  function getNodeVisuals(type) {
    if (type === 'person') {
      return {
        color: {background: '#6aa7ff', border: '#2f79ff'},
        shape: 'dot'
      };
    } else if (type === 'project') {
      return {
        color: {background: '#ce93d8', border: '#ba68c8'},
        shape: 'triangle'
      };
    } else if (type === 'event') {
      return {
        color: {background: '#999999', border: '#666666'},
        shape: 'hexagon'
      };
    } else {
      return {
        color: {background: '#a8dadc', border: '#457b9d'},
        shape: 'box'
      };
    }
  }
  
  // Initialize Google Sheets API
  function initSheetsApi() {
    if (!SHEET_ID || !API_KEY || !CLIENT_ID) {
      console.log('Serverless mode disabled (missing credentials)');
      return;
    }
    
    console.log('üîß Initializing Google Sheets API...');
    
    gapi.load('client', async () => {
      try {
        console.log('üì° Calling gapi.client.init()...');
        await gapi.client.init({
          apiKey: API_KEY,
          discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4']
        });
        console.log('‚úÖ Google Sheets API client initialized (API key mode)');
        
        // Verify sheets API is available
        if (!gapi.client.sheets) {
          console.error('‚ùå gapi.client.sheets not available after init');
          showToast('‚ö†Ô∏è Sheets API requires HTTP/HTTPS (not file://)');
          hideLoading();
          return;
        }
        
        // Auto-load data from Sheets on page init
        loadDataFromSheets().then(() => {
          console.log('üéâ Initial data load complete');
          // Fit graph after a delay to allow physics to settle (more zoomed out)
          if (window.network) {
            setTimeout(() => {
              window.network.fit({ animation: { duration: 1000 }, scale: 0.8 });
              console.log('üéØ Graph fitted to show all nodes (scale 0.8)');
            }, 2000);
          }
        }).catch(err => {
          console.error('Failed to load initial data:', err);
        });
        
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          callback: (response) => {
            if (response.error) {
              console.error('OAuth error:', response.error);
              showToast('‚ùå Authentication failed');
              pendingSaveAfterAuth = false;
              return;
            }
            accessToken = response.access_token;
            gapi.client.setToken({access_token: accessToken});
            sheetsApiReady = true;
            
            localStorage.setItem('gapi_token', JSON.stringify({
              access_token: accessToken,
              expires_at: Date.now() + 3600000
            }));
            
            updateSignInStatus(true);
            console.log('‚úÖ Authenticated with Google Sheets');
            
            if (pendingSaveAfterAuth) {
              pendingSaveAfterAuth = false;
              saveDataToSheets();
            }
          }
        });
        
        const savedToken = localStorage.getItem('gapi_token');
        if (savedToken) {
          try {
            const tokenData = JSON.parse(savedToken);
            if (tokenData.expires_at > Date.now()) {
              accessToken = tokenData.access_token;
              gapi.client.setToken({access_token: accessToken});
              sheetsApiReady = true;
              updateSignInStatus(true);
              console.log('‚úÖ Restored authentication from session');
            } else {
              localStorage.removeItem('gapi_token');
              console.log('‚ö†Ô∏è Saved token expired');
            }
          } catch (e) {
            console.error('Error restoring token:', e);
            localStorage.removeItem('gapi_token');
          }
        }
        
      } catch (error) {
        console.error('Error initializing Google Sheets API:', error);
      }
    });
  }
  
  function updateSignInStatus(isSignedIn) {
    const signInBtn = document.getElementById('signInBtn');
    if (signInBtn) {
      if (isSignedIn) {
        signInBtn.textContent = '‚úì Signed In';
        signInBtn.disabled = true;
        signInBtn.style.opacity = '0.6';
      } else {
        signInBtn.textContent = 'üîê Sign In';
        signInBtn.disabled = false;
        signInBtn.style.opacity = '1';
      }
    }
  }
  
  function handleSignIn() {
    if (!tokenClient) {
      showToast('‚ö†Ô∏è Google Sheets API not ready');
      return;
    }
    tokenClient.requestAccessToken();
  }
  
  async function readSheetTab(tabName) {
    if (!window.gapi || !window.gapi.client || !window.gapi.client.sheets) {
      throw new Error('Google Sheets API not initialized');
    }
    
    const response = await gapi.client.sheets.spreadsheets.values.get({
      spreadsheetId: SHEET_ID,
      range: `${tabName}!A:Z`
    });
    
    const rows = response.result.values || [];
    if (rows.length === 0) return [];
    
    const headers = rows[0];
    return rows.slice(1).map(row => {
      const obj = {};
      headers.forEach((h, i) => obj[h] = row[i] || '');
      return obj;
    });
  }
  
  async function writeSheetTab(tabName, data) {
    if (!window.gapi || !window.gapi.client || !window.gapi.client.sheets) {
      throw new Error('Google Sheets API not initialized');
    }
    
    if (!sheetsApiReady) {
      throw new Error('Not authenticated - please sign in first');
    }
    
    if (data.length === 0) {
      console.warn(`No data to write to ${tabName}`);
      return;
    }
    
    const headers = Object.keys(data[0]);
    const rows = [headers, ...data.map(obj => headers.map(h => obj[h] || ''))];
    
    await gapi.client.sheets.spreadsheets.values.clear({
      spreadsheetId: SHEET_ID,
      range: `${tabName}!A:Z`
    });
    
    await gapi.client.sheets.spreadsheets.values.update({
      spreadsheetId: SHEET_ID,
      range: `${tabName}!A1`,
      valueInputOption: 'RAW',
      resource: { values: rows }
    });
  }
  
  async function loadDataFromSheets() {
    if (!window.gapi || !window.gapi.client || !window.gapi.client.sheets) {
      console.log('‚ö†Ô∏è Google Sheets API not initialized. Skipping auto-load.');
      return null;
    }
    
    try {
      showToast('Loading from Sheets...');
      const [nodesData, edgesData] = await Promise.all([
        readSheetTab('nodes'),
        readSheetTab('edges')
      ]);
      
      console.log(`‚úÖ Loaded ${nodesData.length} nodes, ${edgesData.length} edges from Sheets`);
      
      const nodesPayload = nodesData.map((n, idx) => {
        try {
          // Parse type from ID prefix (Sheet's type column is unreliable)
          const type = parseTypeFromId(n.id);
          const visuals = getNodeVisuals(type);
          
          return {
            id: n.id,
            label: n.label,
            title: n.label,
            group: type,
            type: type,
            shape: visuals.shape,
            color: visuals.color,
            url: n.url || '',
            notes: n.notes || '',
            member: n.member || '',
            origin: n.origin || '',
            hidden: n.hidden === 'true' || n.hidden === true,
            created_at: n.created_at || '',
            updated_at: n.updated_at || ''
          };
        } catch (err) {
          console.error(`Error processing node at index ${idx}:`, n, err);
          throw err;
        }
      });
      
      const edgesPayload = edgesData.map(e => {
        // Check if edge connects to Town Hall event
        const isTownHallEdge = e.source.startsWith('event::Town Hall') || e.target.startsWith('event::Town Hall');
        // Hide "attended" and "follows" labels
        const label = (e.relationship === 'attended' || e.relationship === 'follows') ? '' : (e.relationship || '');
        // Add arrows to "follows" edges
        const arrows = (e.relationship === 'follows') ? { to: { enabled: true, scaleFactor: 0.5 } } : undefined;
        
        return {
          from: e.source,
          to: e.target,
          label: label,
          relationship: e.relationship || '',
          role: e.role || '',
          url: e.url || '',
          notes: e.notes || '',
          created_at: e.created_at || '',
          updated_at: e.updated_at || '',
          arrows: arrows,
          // Town Hall edges: grey, medium opacity (will vary by distance after positioning)
          color: isTownHallEdge ? { color: '#999999', opacity: 0.5 } : undefined,
          width: isTownHallEdge ? 0.5 : 1,
          isTownHallEdge: isTownHallEdge  // Flag for later adjustment
        };
      });
      
      // Auto-heal: Create missing nodes referenced by edges
      const nodeIds = new Set(nodesPayload.map(n => n.id));
      const missingNodes = new Set();
      
      edgesPayload.forEach(edge => {
        if (!nodeIds.has(edge.from)) missingNodes.add(edge.from);
        if (!nodeIds.has(edge.to)) missingNodes.add(edge.to);
      });
      
      if (missingNodes.size > 0) {
        console.warn(`üîß Auto-healing ${missingNodes.size} missing node(s):`);
        missingNodes.forEach(id => {
          const type = parseTypeFromId(id);
          const visuals = getNodeVisuals(type);
          const label = id.replace(/^(person|org|project)::/, ''); // Strip prefix for display
          const healedNode = {
            id: id,
            label: label,
            title: `${label}\n(auto-created from edge reference)`,
            group: type,
            type: type,
            shape: visuals.shape,
            color: visuals.color,
            url: '',
            notes: '',
            member: '',
            origin: 'auto-healed',
            hidden: false,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          };
          nodesPayload.push(healedNode);
          console.warn(`  ‚Üí Created: ${id}`);
        });
        showToast(`üîß Auto-created ${missingNodes.size} missing node(s)`);
      }
      
      nodes.clear();
      edges.clear();
      nodes.add(nodesPayload);
      edges.add(edgesPayload);
      
      // Scale nodes by connection count (but weight TH connections much less)
      const connectionCount = {};
      edgesPayload.forEach(edge => {
        // Town Hall connections count as 0.1 instead of 1 (reduce their impact on node size)
        const weight = edge.isTownHallEdge ? 0.1 : 1;
        connectionCount[edge.from] = (connectionCount[edge.from] || 0) + weight;
        connectionCount[edge.to] = (connectionCount[edge.to] || 0) + weight;
      });
      
      // Update nodes with scaling value while preserving all other properties
      // Events (Town Halls) scale much less severely due to high participant count
      const updates = nodesPayload.map(node => {
        const connections = connectionCount[node.id] || 1;
        const type = parseTypeFromId(node.id);
        // Events scale at 30% rate of other nodes (max 10 instead of full connection count)
        const scaledValue = type === 'event' ? Math.min(connections * 0.3, 10) : connections;
        return {
          ...node,
          value: scaledValue
        };
      });
      nodes.update(updates);
      
      // Set variable edge length based on target node degree
      // Higher degree nodes get longer edges = weaker attraction
      const edgeUpdates = edgesPayload.map(edge => {
        const targetDegree = connectionCount[edge.to] || 1;
        // Base length 120, +10 for each connection up to max 300
        const length = Math.min(120 + (targetDegree * 10), 300);
        return {
          ...edge,
          length: length
        };
      });
      edges.update(edgeUpdates);
      
      // Position Town Hall events in a fixed circle at periphery
      const townHalls = nodesPayload.filter(node => node.id.startsWith('event::Town Hall'));
      const thPositions = {};  // Store positions for distance calculation
      if (townHalls.length > 0) {
        const thUpdates = townHalls.map((node, idx) => {
          // Arrange Town Halls in a large circle (radius 1000px)
          const angle = (idx / townHalls.length) * 2 * Math.PI;
          const radius = 1000;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          thPositions[node.id] = { x, y };
          return {
            ...node,
            x: x,
            y: y,
            fixed: { x: true, y: true },  // Fixed position
            physics: false  // Don't move
          };
        });
        nodes.update(thUpdates);
        console.log(`üéØ Fixed ${townHalls.length} Town Halls in circular ring at periphery`);
        
        // Adjust TH edge opacity based on distance after a delay (let layout settle)
        console.log(`‚è≤Ô∏è Setting up setTimeout for edge adjustment in 4 seconds...`);
        setTimeout(() => {
          console.log(`‚è∞ setTimeout fired after 4 seconds - calling adjustTHEdges()`);
          if (typeof window.adjustTHEdges === 'function') {
            window.adjustTHEdges();
          }
          // Set flag for test automation
          window.__edgeAdjustmentComplete = true;
        }, 4000);  // Wait 4 seconds for layout to fully settle
      }
      
      // Position orphan nodes (no connections) near TH ring to create visible connections
      const orphans = nodesPayload.filter(node => !connectionCount[node.id] && !node.id.startsWith('event::Town Hall'));
      if (orphans.length > 0) {
        const orphanUpdates = orphans.map((node, idx) => {
          // Arrange orphans in inner ring (radius 850px) to be near TH ring (radius 1000px)
          // This creates ~150px distance = thick visible edges
          const angle = (idx / orphans.length) * 2 * Math.PI;
          const radius = 850;  // Changed from 150 to 850 to be near TH ring
          return {
            ...node,
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            fixed: { x: false, y: false },  // Can move but start near TH ring
            physics: true
          };
        });
        nodes.update(orphanUpdates);
        console.log(`üìå Positioned ${orphans.length} orphan nodes in inner ring (radius 850px, near TH ring at 1000px)`);
      }
      
      console.log(`üìä Scaled nodes by connections (min: ${Math.min(...Object.values(connectionCount))}, max: ${Math.max(...Object.values(connectionCount))})`);
      console.log(`üîó Set variable edge lengths (high-degree nodes get longer edges)`);
      
      showToast('‚úÖ Loaded from Sheets');
      hideLoading();
      return { nodes: nodesPayload, edges: edgesPayload };
      
    } catch (error) {
      console.error('Error loading from Sheets:', error);
      console.error('Error details:', {
        message: error?.message,
        stack: error?.stack,
        name: error?.name
      });
      showToast('‚ùå Failed to load from Sheets');
      hideLoading();
      return null;
    }
  }
  
  async function saveDataToSheets() {
    if (!sheetsApiReady) {
      console.log('‚ö†Ô∏è Not authenticated - requesting sign in...');
      showToast('‚ö†Ô∏è Sign in required to save');
      pendingSaveAfterAuth = true;
      handleSignIn();
      return;
    }
    
    try {
      showToast('Saving to Sheets...');
      
      const nodesData = nodes.get().map(n => ({
        id: n.id,
        label: n.label,
        type: n.type || 'organization',
        url: n.url || '',
        notes: n.notes || '',
        member: n.member || '',
        origin: n.origin || '',
        hidden: n.hidden ? 'true' : '',
        created_at: n.created_at || '',
        updated_at: new Date().toISOString()
      }));
      
      const edgesData = edges.get().map(e => ({
        source: e.from,
        target: e.to,
        relationship: e.relationship || e.label,
        role: e.role || '',
        url: e.url || '',
        notes: e.notes || '',
        created_at: e.created_at || '',
        updated_at: new Date().toISOString()
      }));
      
      await Promise.all([
        writeSheetTab('nodes', nodesData),
        writeSheetTab('edges', edgesData)
      ]);
      
      console.log('‚úÖ Saved to Sheets');
      showToast('‚úÖ Saved to Sheets');
      
    } catch (error) {
      console.error('Error saving to Sheets:', error);
      showToast('‚ùå Failed to save: ' + error.message);
    }
  }
  
  function hideLoading() {
    const loadingEl = document.getElementById('loading');
    if (loadingEl) loadingEl.style.display = 'none';
  }
  
  // Initialize on page load
  if (SHEET_ID && API_KEY && CLIENT_ID) {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initSheetsApi);
    } else {
      initSheetsApi();
    }
  }
  
  // ========== Graph Data ==========
  
  // Start with empty datasets - data will be loaded from Sheets
  const nodes = new vis.DataSet([]);
  const edges = new vis.DataSet([]);
  const candidatesByOrgId = {};
  const existingPartnersByOrgId = {"org::Test Person A": ["Test Person B"]};
  
  // ========== Physics Controls ==========
  // Load saved settings from localStorage or use defaults
  let physicsConfig = {
    centralGravity: 0.15,
    springLength: 120,
    springConstant: 0.02,
    avoidOverlap: 0.2,
    edgeMultiplier: 10,
    maxEdgeLength: 300
  };
  
  // Try to load saved settings
  try {
    const saved = localStorage.getItem('era_physics_settings');
    if (saved) {
      physicsConfig = JSON.parse(saved);
      console.log('üì¶ Loaded saved physics settings:', physicsConfig);
    }
  } catch (e) {
    console.warn('Could not load saved physics settings:', e);
  }
  
  // Store original edge data
  let originalEdges = [];
  
  // Open physics modal and sync sliders with saved config
  document.getElementById('physicsBtn').onclick = () => {
    // Update sliders to match saved config
    document.getElementById('centralGravity').value = physicsConfig.centralGravity;
    document.getElementById('springLength').value = physicsConfig.springLength;
    document.getElementById('springConstant').value = physicsConfig.springConstant;
    document.getElementById('avoidOverlap').value = physicsConfig.avoidOverlap;
    document.getElementById('edgeMultiplier').value = physicsConfig.edgeMultiplier;
    document.getElementById('maxEdgeLength').value = physicsConfig.maxEdgeLength;
    
    // Update value displays
    document.getElementById('centralGravityVal').textContent = physicsConfig.centralGravity;
    document.getElementById('springLengthVal').textContent = physicsConfig.springLength;
    document.getElementById('springConstantVal').textContent = physicsConfig.springConstant;
    document.getElementById('avoidOverlapVal').textContent = physicsConfig.avoidOverlap;
    document.getElementById('edgeMultiplierVal').textContent = physicsConfig.edgeMultiplier;
    document.getElementById('maxEdgeLengthVal').textContent = physicsConfig.maxEdgeLength;
    
    document.getElementById('physicsModal').style.display = 'flex';
  };
  
  
  // Update slider value displays and apply changes in real-time
  ['centralGravity', 'springLength', 'springConstant', 'avoidOverlap', 'edgeMultiplier', 'maxEdgeLength'].forEach(id => {
    const slider = document.getElementById(id);
    const valueSpan = document.getElementById(id + 'Val');
    
    function updateValuePosition() {
      // Calculate position based on slider value
      const percent = (slider.value - slider.min) / (slider.max - slider.min);
      const sliderWidth = slider.offsetWidth;
      const thumbWidth = 20; // approximate thumb width
      const position = percent * (sliderWidth - thumbWidth) + thumbWidth/2;
      valueSpan.style.left = position + 'px';
      valueSpan.textContent = slider.value;
    }
    
    slider.oninput = () => {
      updateValuePosition();
      // Apply changes immediately, mark as from slider
      applyPhysicsSettings(true);
    };
    
    // Initial position
    updateValuePosition();
  });
  
  // Apply physics changes (extracted as function for reuse)
  let stabilizationTimeout;
  let isAdjustingPhysics = false;
  
  function applyPhysicsSettings(fromSlider = false) {
    // Read values
    physicsConfig.centralGravity = parseFloat(document.getElementById('centralGravity').value);
    physicsConfig.springLength = parseFloat(document.getElementById('springLength').value);
    physicsConfig.springConstant = parseFloat(document.getElementById('springConstant').value);
    physicsConfig.avoidOverlap = parseFloat(document.getElementById('avoidOverlap').value);
    physicsConfig.edgeMultiplier = parseFloat(document.getElementById('edgeMultiplier').value);
    physicsConfig.maxEdgeLength = parseFloat(document.getElementById('maxEdgeLength').value);
    
    // Save to localStorage
    localStorage.setItem('centralGravity', physicsConfig.centralGravity);
    localStorage.setItem('springLength', physicsConfig.springLength);
    localStorage.setItem('springConstant', physicsConfig.springConstant);
    localStorage.setItem('avoidOverlap', physicsConfig.avoidOverlap);
    localStorage.setItem('edgeMultiplier', physicsConfig.edgeMultiplier);
    localStorage.setItem('maxEdgeLength', physicsConfig.maxEdgeLength);
    
    // Apply physics settings
    if (window.network) {
      isAdjustingPhysics = fromSlider;
      
      window.network.setOptions({
        physics: {
          enabled: true,  // Ensure physics stays enabled
          barnesHut: {
            gravitationalConstant: -2000,
            centralGravity: physicsConfig.centralGravity,
            springLength: physicsConfig.springLength,
            springConstant: physicsConfig.springConstant,
            damping: 0.35,  // Keep high damping for faster settling
            avoidOverlap: physicsConfig.avoidOverlap
          },
          maxVelocity: 50,
          minVelocity: 2.5,  // Keep higher threshold for faster stopping
          solver: 'barnesHut',
          timestep: 0.35,   // Keep reduced timestep for smoother settling
          adaptiveTimestep: true,
          stabilization: false  // Never lock nodes - always keep draggable
        }
      });
      
      // Recalculate edge lengths based on new parameters
      const connectionCount = {};
      edges.get().forEach(edge => {
        connectionCount[edge.from] = (connectionCount[edge.from] || 0) + 1;
        connectionCount[edge.to] = (connectionCount[edge.to] || 0) + 1;
      });
      
      const edgeUpdates = edges.get().map(edge => {
        const targetDegree = connectionCount[edge.to] || 1;
        const length = Math.min(physicsConfig.springLength + (targetDegree * physicsConfig.edgeMultiplier), physicsConfig.maxEdgeLength);
        return {
          ...edge,
          length: length
        };
      });
      edges.update(edgeUpdates);
      
      // No stabilization - let physics naturally settle with high damping
      
      console.log('‚öôÔ∏è Physics updated:', physicsConfig, 'fromSlider:', fromSlider);
    }
  }
  
  // Done button closes modal
  document.getElementById('applyPhysics').onclick = () => {
    document.getElementById('physicsModal').style.display = 'none';
    clearTimeout(stabilizationTimeout);
    isAdjustingPhysics = false;
    showToast('‚öôÔ∏è Physics saved');
  };
  
  // Reset to defaults
  document.getElementById('resetPhysics').onclick = () => {
    document.getElementById('centralGravity').value = 0.15;
    document.getElementById('springLength').value = 120;
    document.getElementById('springConstant').value = 0.02;
    document.getElementById('avoidOverlap').value = 0.2;
    document.getElementById('edgeMultiplier').value = 10;
    document.getElementById('maxEdgeLength').value = 300;
    
    // Update displays
    document.getElementById('centralGravityVal').textContent = '0.15';
    document.getElementById('springLengthVal').textContent = '120';
    document.getElementById('springConstantVal').textContent = '0.02';
    document.getElementById('avoidOverlapVal').textContent = '0.2';
    document.getElementById('edgeMultiplierVal').textContent = '10';
    document.getElementById('maxEdgeLengthVal').textContent = '300';
    
    // Apply defaults immediately
    applyPhysicsSettings();
  };
  
  // ========== Network Settings Controls ==========
  
  // Network settings configuration
  let networkConfig = {
    scalingIntensity: parseFloat(localStorage.getItem('scalingIntensity') || '1.0'),
    nodeSize: parseFloat(localStorage.getItem('nodeSize') || '1.0'),
    edgeFading: parseFloat(localStorage.getItem('edgeFading') || '1.0'),
    edgeThickness: parseFloat(localStorage.getItem('edgeThickness') || '1.0')
  };
  
  // Open network modal
  document.getElementById('networkBtn').onclick = () => {
    document.getElementById('scalingIntensity').value = networkConfig.scalingIntensity;
    document.getElementById('nodeSize').value = networkConfig.nodeSize;
    document.getElementById('edgeFading').value = networkConfig.edgeFading;
    document.getElementById('edgeThickness').value = networkConfig.edgeThickness;
    
    document.getElementById('scalingIntensityVal').textContent = networkConfig.scalingIntensity;
    document.getElementById('nodeSizeVal').textContent = networkConfig.nodeSize;
    document.getElementById('edgeFadingVal').textContent = networkConfig.edgeFading;
    document.getElementById('edgeThicknessVal').textContent = networkConfig.edgeThickness;
    
    document.getElementById('networkModal').style.display = 'flex';
  };
  
  // Network slider handlers
  ['scalingIntensity', 'nodeSize', 'edgeFading', 'edgeThickness'].forEach(id => {
    const slider = document.getElementById(id);
    const valueSpan = document.getElementById(id + 'Val');
    
    function updateValuePosition() {
      const percent = (slider.value - slider.min) / (slider.max - slider.min);
      const sliderWidth = slider.offsetWidth;
      const thumbWidth = 20;
      const position = percent * (sliderWidth - thumbWidth) + thumbWidth/2;
      valueSpan.style.left = position + 'px';
      valueSpan.textContent = slider.value;
    }
    
    slider.oninput = () => {
      updateValuePosition();
      applyNetworkSettings();
    };
    
    updateValuePosition();
  });
  
  // Extract TH edge adjustment as reusable function
  window.adjustTHEdges = function() {
    const allEdges = edges.get();
    const edgeOpacityUpdates = [];
    let nearCount = 0, medCount = 0, farCount = 0;
    
    allEdges.forEach(edge => {
      if (edge.isTownHallEdge && edge.relationship !== 'follows') {
        try {
          const fromPos = window.network.getPositions([edge.from])[edge.from];
          const toPos = window.network.getPositions([edge.to])[edge.to];
        
          if (fromPos && toPos && fromPos.x !== undefined && toPos.x !== undefined) {
            const dx = fromPos.x - toPos.x;
            const dy = fromPos.y - toPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            let baseOpacity = 0.05;
            let baseWidth = 0.5;
            if (distance < 450) {
              baseOpacity = 0.8;
              baseWidth = 2.5;
              nearCount++;
            } else if (distance < 700) {
              baseOpacity = 0.8 - (distance - 450) / 250 * 0.6;
              baseWidth = 1;
              medCount++;
            } else if (distance < 1000) {
              baseOpacity = 0.2 - (distance - 700) / 300 * 0.15;
              farCount++;
            } else {
              farCount++;
            }
            
            // Apply fading and thickness from Network settings
            const fadeFactor = networkConfig.edgeFading;
            const opacity = baseOpacity * (1 - fadeFactor * 0.5);
            const thicknessFactor = networkConfig.edgeThickness;
            const width = baseWidth * (1 + thicknessFactor * 0.5);
            
            edgeOpacityUpdates.push({
              id: edge.id,
              color: { color: '#999999', opacity: opacity },
              width: width
            });
          }
        } catch (err) {
          // Skip if position unavailable
        }
      }
    });
    
    if (edgeOpacityUpdates.length > 0) {
      edges.update(edgeOpacityUpdates);
      console.log(`üëÅÔ∏è Adjusted ${edgeOpacityUpdates.length} TH‚Üíperson edges: ${nearCount} near, ${medCount} medium, ${farCount} far (fade=${networkConfig.edgeFading}, thickness=${networkConfig.edgeThickness})`);
    }
  };
  
  function applyNetworkSettings() {
    networkConfig.scalingIntensity = parseFloat(document.getElementById('scalingIntensity').value);
    networkConfig.nodeSize = parseFloat(document.getElementById('nodeSize').value);
    networkConfig.edgeFading = parseFloat(document.getElementById('edgeFading').value);
    networkConfig.edgeThickness = parseFloat(document.getElementById('edgeThickness').value);
    
    // Save to localStorage
    localStorage.setItem('scalingIntensity', networkConfig.scalingIntensity);
    localStorage.setItem('nodeSize', networkConfig.nodeSize);
    localStorage.setItem('edgeFading', networkConfig.edgeFading);
    localStorage.setItem('edgeThickness', networkConfig.edgeThickness);
    
    // Reapply node scaling with new intensity
    const connectionCount = {};
    edges.get().forEach(edge => {
      const weight = edge.isTownHallEdge ? 0.1 : 1;
      connectionCount[edge.from] = (connectionCount[edge.from] || 0) + weight;
      connectionCount[edge.to] = (connectionCount[edge.to] || 0) + weight;
    });
    
    const updates = nodes.get().map(node => {
      const connections = connectionCount[node.id] || 1;
      const type = parseTypeFromId(node.id);
      
      if (type === 'event') {
        return {
          ...node,
          value: Math.min(connections * 0.3, 10)
        };
      }
      
      const constantScale = 10;
      const logScale = Math.log(connections + 1);
      const blendedScale = constantScale + (logScale - constantScale) * networkConfig.scalingIntensity;
      
      // Apply overall node size multiplier
      const finalValue = blendedScale * networkConfig.nodeSize;
      
      return {
        ...node,
        value: finalValue
      };
    });
    nodes.update(updates);
    
    // Re-adjust TH edges with new fading/thickness settings
    if (typeof window.adjustTHEdges === 'function') {
      window.adjustTHEdges();
    }
    
    console.log(`üåê Applied network settings: scaling=${networkConfig.scalingIntensity}, size=${networkConfig.nodeSize}, fading=${networkConfig.edgeFading}, thickness=${networkConfig.edgeThickness}`);
  }
  
  document.getElementById('applyNetwork').onclick = () => {
    document.getElementById('networkModal').style.display = 'none';
  };
  
  document.getElementById('resetNetwork').onclick = () => {
    networkConfig = { scalingIntensity: 1.0, nodeSize: 1.0, edgeFading: 1.0, edgeThickness: 1.0 };
    document.getElementById('scalingIntensity').value = 1.0;
    document.getElementById('nodeSize').value = 1.0;
    document.getElementById('edgeFading').value = 1.0;
    document.getElementById('edgeThickness').value = 1.0;
    document.getElementById('scalingIntensityVal').textContent = '1.0';
    document.getElementById('nodeSizeVal').textContent = '1.0';
    document.getElementById('edgeFadingVal').textContent = '1.0';
    document.getElementById('edgeThicknessVal').textContent = '1.0';
    applyNetworkSettings();
  };
  
  // Refresh button reloads data
  document.getElementById('refreshBtn').onclick = async () => {
    loadDataFromSheets();
  };
  
  // Make physics modal draggable
  (function(){
    const panel = document.getElementById('physicsPanel');
    let drag = false; let sx=0, sy=0, ox=0, oy=0;
    const handle = document.getElementById('physicsHandle');
    handle.addEventListener('mousedown', (e)=>{ 
      drag=true; 
      sx=e.clientX; 
      sy=e.clientY; 
      const r=panel.getBoundingClientRect(); 
      ox=r.left; 
      oy=r.top; 
      panel.style.position='fixed'; 
      e.preventDefault(); 
    });
    window.addEventListener('mousemove', (e)=>{ 
      if(!drag) return; 
      const dx=e.clientX-sx; 
      const dy=e.clientY-sy; 
      panel.style.left=(ox+dx)+"px"; 
      panel.style.top=(oy+dy)+"px"; 
    });
    window.addEventListener('mouseup', ()=>{ drag=false; });
  })();
  
  // Make network modal draggable
  (function(){
    const panel = document.getElementById('networkPanel');
    let drag = false; let sx=0, sy=0, ox=0, oy=0;
    const handle = document.getElementById('networkHandle');
    handle.addEventListener('mousedown', (e)=>{ 
      drag=true; 
      sx=e.clientX; 
      sy=e.clientY; 
      const r=panel.getBoundingClientRect(); 
      ox=r.left; 
      oy=r.top; 
      panel.style.position='fixed'; 
      e.preventDefault(); 
    });
    window.addEventListener('mousemove', (e)=>{ 
      if(!drag) return; 
      const dx=e.clientX-sx; 
      const dy=e.clientY-sy; 
      panel.style.left=(ox+dx)+"px"; 
      panel.style.top=(oy+dy)+"px"; 
    });
    window.addEventListener('mouseup', ()=>{ drag=false; });
  })();
</script>
<script src="./graph.js"></script>
</body>
</html>